<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√¨nh Qu·∫£n L√Ω API Key</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Be Vietnam Pro', sans-serif; }
        .key-card { transition: all 0.3s ease-in-out; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; }
        .status-active { background-color: #22c55e; }
        .status-invalid { background-color: #ef4444; }
        .status-limited { background-color: #f59e0b; }
        .status-unknown { background-color: #9ca3af; }
        .status-checking { background-color: #3b82f6; animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .toast { visibility: hidden; opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s linear; }
        .toast.show { visibility: visible; opacity: 1; transition: opacity 0.5s linear; }
        .btn-gradient { background-size: 200% auto; transition: background-position 0.5s ease; }
        .btn-gradient:hover { background-position: right center; }
        .loader {
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        .favorite-btn.is-favorite i {
            font-weight: 900; /* Makes the star solid */
            color: #facc15; /* yellow-400 */
        }
        /* Modal Styles */
        .modal-overlay {
            transition: opacity 0.3s ease;
        }
        /* Custom table styles */
        .api-group-table th, .api-group-table td {
            padding: 0.75rem;
            text-align: left;
            vertical-align: middle; /* Changed to middle for better alignment */
        }
        .api-group-table thead th {
            background-color: #f3f4f6; /* gray-100 */
            font-weight: 600;
            color: #374151; /* gray-700 */
        }
        .api-group-table tbody tr:nth-child(even) {
            background-color: #f9fafb; /* gray-50 */
        }
        .api-group-table tbody tr:hover {
            background-color: #eff6ff; /* blue-50 */
        }
        /* Removed Drag and Drop styles */
    </style>
</head>
<body class="bg-[#fffbbe] text-gray-800">
    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        <header id="app-header" class="flex justify-between items-center mb-10 hidden">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">Tr√¨nh Qu·∫£n L√Ω API Key</h1>
            <div id="user-info" class="flex items-center gap-4">
                <div class="text-right"><p id="user-name" class="font-semibold text-gray-900"></p></div>
                <img id="user-avatar" class="w-12 h-12 rounded-full" src="" alt="User Avatar">
                <button id="sign-out-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition">ƒêƒÉng xu·∫•t</button>
            </div>
        </header>

        <div id="login-view" class="text-center py-20">
             <h1 class="text-4xl font-bold text-gray-900">TRANG QU·∫¢N L√ù API C·ª¶A TR·ª¢ L√ù PMTL.SITE</h1>
            <p class="text-gray-600 mt-2 mb-8">Ph·ª•ng S·ª± Vi√™n Ph√°p M√¥n T√¢m Linh.</p>
            <div id="gsi-button" class="inline-block"></div>
        </div>

        <main id="app-content" class="hidden">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-10">
                <h2 class="text-xl font-semibold mb-4 text-gray-900">Th√™m Key M·ªõi</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="md:col-span-2">
                        <label for="api-key-input" class="block text-sm font-medium text-gray-600 mb-1">D√°n API Key v√†o ƒë√¢y</label>
                        <div class="relative">
                            <input type="text" id="api-key-input" placeholder="Key s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông nh·∫≠n di·ªán..." class="w-full bg-gray-50 border-gray-300 rounded-lg py-3 pl-4 pr-10 text-gray-900 focus:ring-indigo-500 focus:border-indigo-500 font-mono text-sm">
                            <div id="detected-api-logo" class="absolute inset-y-0 right-0 flex items-center pr-3"></div>
                        </div>
                    </div>
                    <div>
                        <label for="key-name-input" class="block text-sm font-medium text-gray-600 mb-1">T√™n g·ª£i nh·ªõ</label>
                        <input type="text" id="key-name-input" placeholder="V√≠ d·ª•: Project h√¨nh ·∫£nh" class="w-full bg-gray-50 border-gray-300 rounded-lg py-3 px-4 text-gray-900 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
                <button id="add-key-btn" class="mt-4 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <i class="fas fa-plus-circle mr-2"></i>L∆∞u Key
                </button>
            </div>
            <div>
                <div class="flex flex-col sm:flex-row justify-between items-center mb-6">
                    <h2 class="text-2xl font-semibold text-gray-900 mb-4 sm:mb-0">Danh s√°ch API Keys</h2>
                    <button id="check-all-btn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition flex items-center justify-center gap-2 disabled:bg-gray-400">
                        <i class="fas fa-tasks"></i>
                        <span id="check-all-btn-text">Ki·ªÉm tra t·∫•t c·∫£</span>
                        <div id="check-all-loader" class="loader hidden"></div>
                    </button>
                </div>
                <!-- V√πng hi·ªÉn th·ªã c√°c nh√≥m API key -->
                <div id="key-groups-container" class="space-y-8">
                    <!-- C√°c nh√≥m API key s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
                </div>
            </div>
        </main>
    </div>

    <!-- Template cho h√†ng API key trong b·∫£ng -->
    <template id="key-row-template">
        <tr class="key-row" data-id="" data-value="" data-type="" data-favorite="" data-order="">
            <td class="py-3 px-2 border-b border-gray-200">
                <div class="flex items-center gap-2">
                    <button title="ƒê√°nh d·∫•u y√™u th√≠ch" class="favorite-btn p-1 text-gray-400 hover:text-yellow-400 rounded-lg transition-colors">
                        <i class="far fa-star"></i>
                    </button>
                    <!-- Th√™m contenteditable ƒë·ªÉ s·ª≠a t√™n g·ª£i nh·ªõ -->
                    <span class="card-name text-sm font-medium text-gray-900 break-all" contenteditable="true"></span>
                </div>
            </td>
            <td class="py-3 px-2 border-b border-gray-200">
                <div class="flex items-center gap-2">
                    <p class="card-masked-key font-mono text-xs text-gray-500 break-all flex-grow"></p>
                    <button title="Sao ch√©p key" class="copy-btn p-1 text-gray-400 hover:text-indigo-600 rounded-lg transition-colors">
                        <i class="far fa-copy"></i>
                    </button>
                </div>
            </td>
            <td class="py-3 px-2 border-b border-gray-200">
                <div class="flex items-center gap-1">
                    <div class="status-dot flex-shrink-0"></div>
                    <p class="card-status-text text-xs text-gray-600 flex-grow">Ch∆∞a ki·ªÉm tra</p>
                </div>
            </td>
            <td class="py-3 px-2 border-b border-gray-200">
                <textarea class="card-notes w-full bg-gray-50 p-1 rounded-md text-xs text-gray-800 resize-none border border-gray-200 focus:ring-1 focus:ring-indigo-500" rows="1" placeholder="Th√™m ghi ch√∫..."></textarea>
            </td>
            <td class="py-3 px-2 border-b border-gray-200 text-right">
                <div class="flex items-center justify-end space-x-1">
                    <!-- N√∫t di chuy·ªÉn l√™n/xu·ªëng -->
                    <button title="Di chuy·ªÉn l√™n" class="move-up-btn bg-gray-200 hover:bg-blue-200 text-gray-700 hover:text-blue-800 text-xs font-bold py-1 px-2 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"><i class="fas fa-arrow-up"></i></button>
                    <button title="Di chuy·ªÉn xu·ªëng" class="move-down-btn bg-gray-200 hover:bg-blue-200 text-gray-700 hover:text-blue-800 text-xs font-bold py-1 px-2 rounded-lg transition disabled:opacity-50 disabled:cursor-not-allowed"><i class="fas fa-arrow-down"></i></button>
                    <button class="check-btn btn-gradient text-white text-xs font-bold py-1 px-2 rounded-lg transition duration-300 flex items-center gap-1"><i class="fas fa-sync-alt"></i><span class="btn-text">Ki·ªÉm tra</span><div class="loader hidden"></div></button>
                    <button class="delete-btn bg-gray-200 hover:bg-red-200 text-gray-700 hover:text-red-800 text-xs font-bold py-1 px-2 rounded-lg transition"><i class="fas fa-trash"></i></button>
                </div>
            </td>
        </tr>
    </template>

    <!-- Toast th√¥ng b√°o nhanh -->
    <div id="toast" class="toast fixed bottom-5 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-5 rounded-lg shadow-lg"></div>

    <!-- Modal X√°c nh·∫≠n X√≥a -->
    <div id="delete-confirm-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-bold text-gray-900 mb-4">X√°c nh·∫≠n x√≥a</h3>
            <p class="text-gray-600 mb-6">B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a API key n√†y kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-delete-btn" class="py-2 px-4 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">H·ªßy</button>
                <button id="confirm-delete-btn" class="py-2 px-4 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">X√≥a</button>
            </div>
        </div>
    </div>
    
    <!-- Modal Chi ti·∫øt Tr·∫°ng th√°i API -->
    <div id="status-details-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
            <div id="modal-header" class="flex justify-between items-center p-4 border-b rounded-t-lg">
                <h3 id="modal-title" class="text-xl font-bold">Chi ti·∫øt Tr·∫°ng th√°i API</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
            </div>
            <div class="p-5">
                <div class="mb-4">
                    <p class="font-semibold text-gray-800">Tr·∫°ng th√°i:</p>
                    <p id="modal-status" class="text-gray-700 p-2 rounded-md font-medium"></p>
                </div>
                <div class="mb-4">
                    <p class="font-semibold text-gray-800">Th√¥ng ƒëi·ªáp t·ª´ API (g·ªëc):</p>
                    <p id="modal-message" class="text-sm text-gray-700 bg-gray-100 p-3 rounded-md font-mono"></p>
                </div>
                <div>
                    <p class="font-semibold text-gray-800">üí° Khuy·∫øn ngh·ªã:</p>
                    <p id="modal-advice" class="text-gray-600"></p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        // --- C·∫•u h√¨nh ---
        const GOOGLE_CLIENT_ID = '833528835955-t7pai7q2tb836dqggme3h3560n58s6au.apps.googleusercontent.com';
        const BACKEND_URL = 'https://quanly-backen.onrender.com';
        let idToken = null;
        let keyIdToDelete = null;
        let allLoadedKeys = []; // Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ t·∫•t c·∫£ c√°c key ƒë√£ t·∫£i

        const API_PROVIDERS = {
            'google-ai': { name: 'Google AI (Gemini)', regex: /^AIzaSy[A-Za-z0-9_-]{33}$/, logo: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-blue-500"><path d="M21.35,11.1H12.18V13.83H18.69C18.36,17.64 15.19,19.27 12.19,19.27C8.36,19.27 5,16.25 5,12C5,7.9 8.2,4.73 12.18,4.73C15.29,4.73 17.1,6.7 17.1,6.7L19,4.72C19,4.72 16.56,2 12.18,2C6.42,2 2.03,6.8 2.03,12C2.03,17.05 6.16,22 12.18,22C17.6,22 21.54,18.33 21.54,12.81C21.54,11.76 21.45,11.44 21.35,11.1Z"/></svg>`, gradient: 'from-blue-500 to-green-500' },
            'hugging-face': { name: 'Hugging Face', regex: /^hf_[A-Za-z0-9]{30,}/, logo: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-yellow-500"><path d="M20.25 14.183C20.25 13.202 19.431 12.383 18.45 12.383C17.469 12.383 16.65 13.202 16.65 14.183C16.65 15.164 17.469 15.983 18.45 15.983C19.431 15.983 20.25 15.164 20.25 14.183ZM15.15 14.183C15.15 13.202 14.331 12.383 13.35 12.383C12.369 12.383 11.55 13.202 11.55 14.183C11.55 15.164 12.369 15.983 13.35 15.983C14.331 15.983 15.15 15.164 15.15 14.183ZM12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22C6.477 22 2 17.523 2 12C2 6.477 6.477 2 12 2ZM12 4C7.582 4 4 7.582 4 12C4 16.418 7.582 20 12 20C16.418 20 20 16.418 20 12C20 7.582 16.418 4 12 4ZM8.85 14.183C8.85 13.202 8.031 12.383 7.05 12.383C6.069 12.383 5.25 13.202 5.25 14.183C5.25 15.164 6.069 15.983 7.05 15.983C8.031 15.983 8.85 15.164 8.85 14.183Z"/></svg>`, gradient: 'from-yellow-500 to-orange-500' },
            'stability-ai': { name: 'Stability AI', regex: /^sk-[A-Za-z0-9]{40,}/, logo: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-purple-500"><path d="M12 2L9.429 9.429 2 12l7.429 2.571L12 22l2.571-7.429L22 12l-7.429-2.571z"/></svg>`, gradient: 'from-purple-500 to-pink-500' },
            'openai': { name: 'OpenAI', regex: /^sk-[A-Za-z0-9]{20,}/, logo: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-teal-500"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>`, gradient: 'from-teal-500 to-cyan-500' },
        };

        // --- Logic Giao ti·∫øp Backend ---
        async function apiFetch(endpoint, options = {}) {
            if (!idToken) throw new Error("User not authenticated");
            const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${idToken}`, ...options.headers };
            let response;
            try {
                response = await fetch(`${BACKEND_URL}${endpoint}`, { ...options, headers });
            } catch (networkError) {
                console.error("Network error:", networkError);
                throw new Error("L·ªói m·∫°ng. Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß.");
            }
            if (!response.ok) {
                let errorMsg = `L·ªói HTTP! M√£: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMsg = errorData.error || JSON.stringify(errorData);
                } catch (e) {
                    errorMsg = `L·ªói m√°y ch·ªß (M√£: ${response.status}). Kh√¥ng th·ªÉ ƒë·ªçc ph·∫£n h·ªìi.`;
                }
                throw new Error(errorMsg);
            }
            if (response.status === 204) return null;
            try {
                return await response.json();
            } catch (e) {
                if (e instanceof SyntaxError) {
                    console.error("Failed to parse JSON response. Backend might be misconfigured.", e);
                    throw new Error("L·ªói giao ti·∫øp: Backend tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i c·∫•u h√¨nh BACKEND_URL.");
                }
                throw e;
            }
        }

        // --- X√°c th·ª±c Google & Qu·∫£n l√Ω UI ---
        function decodeJwtPayload(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error("Error decoding JWT", e);
                return null;
            }
        }

        function initializeAuthenticatedApp(token) {
            idToken = token;
            const userProfile = decodeJwtPayload(idToken);
            if (!userProfile) {
                showToast("Kh√¥ng th·ªÉ gi·∫£i m√£ th√¥ng tin ng∆∞·ªùi d√πng.");
                return;
            }
            document.getElementById('user-name').textContent = userProfile.name;
            document.getElementById('user-avatar').src = userProfile.picture;
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('app-header').classList.remove('hidden');
            document.getElementById('app-content').classList.remove('hidden');
            loadKeys();
        }

        window.onload = function () {
            if (GOOGLE_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID' || BACKEND_URL === 'YOUR_RENDER_BACKEND_URL') {
                document.getElementById('login-view').innerHTML = `<h2 class="text-2xl text-red-500 font-bold">L·ªói C·∫•u H√¨nh Frontend</h2><p class="text-gray-600 mt-2">Vui l√≤ng ƒëi·ªÅn GOOGLE_CLIENT_ID v√† BACKEND_URL trong t·ªáp HTML.</p>`;
                return;
            }
            const storedIdToken = localStorage.getItem('idToken');
            if (storedIdToken) {
                initializeAuthenticatedApp(storedIdToken);
            } else {
                google.accounts.id.initialize({ client_id: GOOGLE_CLIENT_ID, callback: handleCredentialResponse, auto_select: true });
                google.accounts.id.renderButton(document.getElementById("gsi-button"), { theme: "outline", size: "large", text: "signin_with", shape: "rectangular" });
            }
        };

        function handleCredentialResponse(response) {
            localStorage.setItem('idToken', response.credential);
            initializeAuthenticatedApp(response.credential);
        }

        document.getElementById('sign-out-btn').addEventListener('click', () => {
            idToken = null;
            localStorage.removeItem('idToken');
            google.accounts.id.disableAutoSelect();
            document.getElementById('login-view').classList.remove('hidden');
            document.getElementById('app-header').classList.add('hidden');
            document.getElementById('app-content').classList.add('hidden');
            google.accounts.id.initialize({ client_id: GOOGLE_CLIENT_ID, callback: handleCredentialResponse });
            google.accounts.id.renderButton(document.getElementById("gsi-button"), { theme: "outline", size: "large", text: "signin_with", shape: "rectangular" });
        });

        // --- Logic CRUD & Hi·ªÉn th·ªã ---
        const apiKeyInput = document.getElementById('api-key-input');
        const keyNameInput = document.getElementById('key-name-input');
        const addKeyBtn = document.getElementById('add-key-btn');
        const keyGroupsContainer = document.getElementById('key-groups-container');
        const detectedApiLogo = document.getElementById('detected-api-logo');
        const keyRowTemplate = document.getElementById('key-row-template');
        const checkAllBtn = document.getElementById('check-all-btn');
        
        const deleteConfirmModal = document.getElementById('delete-confirm-modal');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        const cancelDeleteBtn = document.getElementById('cancel-delete-btn');

        const statusDetailsModal = document.getElementById('status-details-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');

        async function loadKeys() {
            try {
                const keys = await apiFetch('/api/keys');
                allLoadedKeys = keys.map(key => ({
                    ...key,
                    order: key.order ?? new Date(key.created_at).getTime()
                }));
                renderKeys(allLoadedKeys);
            } catch (error) {
                showToast(`L·ªói t·∫£i keys: ${error.message}`);
            }
        }

        function renderKeys(keysToRender) {
            keyGroupsContainer.innerHTML = '';

            if (!keysToRender || keysToRender.length === 0) {
                keyGroupsContainer.innerHTML = `<p class="text-gray-500 col-span-full text-center">B·∫°n ch∆∞a c√≥ API key n√†o.</p>`;
                return;
            }

            const groupedKeys = keysToRender.reduce((acc, key) => {
                const type = key.type || 'unknown';
                if (!acc[type]) acc[type] = [];
                acc[type].push(key);
                return acc;
            }, {});

            const sortedProviderTypes = Object.keys(API_PROVIDERS).filter(type => groupedKeys[type]);
            if (groupedKeys['unknown']) sortedProviderTypes.push('unknown');

            sortedProviderTypes.forEach(type => {
                const provider = API_PROVIDERS[type] || { name: 'Lo·∫°i kh√¥ng x√°c ƒë·ªãnh', logo: '' };
                const keysInGroup = groupedKeys[type].sort((a, b) => (b.favorite ? 1 : 0) - (a.favorite ? 1 : 0) || a.order - b.order);

                const groupDiv = document.createElement('div');
                groupDiv.className = 'bg-white p-6 rounded-xl shadow-lg';
                groupDiv.dataset.type = type;

                groupDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-gray-900 flex items-center gap-2">
                            ${provider.logo}
                            <span>${provider.name} Keys</span>
                        </h3>
                        <button class="check-group-btn w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition flex items-center justify-center gap-2 disabled:bg-gray-400">
                            <i class="fas fa-sync-alt"></i>
                            <span class="btn-text">Ki·ªÉm tra t·∫•t c·∫£ ${provider.name}</span>
                            <div class="loader hidden"></div>
                        </button>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 api-group-table">
                            <thead>
                                <tr>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">T√™n g·ª£i nh·ªõ</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">API Key</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/6">Tr·∫°ng th√°i</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">Ghi ch√∫</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider text-right" style="min-width: 150px;">H√†nh ƒë·ªông</th>
                                </tr>
                            </thead>
                            <tbody>
                            </tbody>
                        </table>
                    </div>
                `;
                
                const tbody = groupDiv.querySelector('tbody');
                keysInGroup.forEach((key, index) => {
                    const row = keyRowTemplate.content.cloneNode(true).firstElementChild;
                    row.dataset.id = key.id;
                    row.dataset.value = key.value;
                    row.dataset.type = key.type;
                    row.dataset.favorite = String(key.favorite);
                    row.dataset.order = String(key.order);

                    const nameSpan = row.querySelector('.card-name');
                    nameSpan.textContent = key.name;
                    nameSpan.dataset.originalName = key.name;

                    row.querySelector('.card-masked-key').textContent = `${key.value.substring(0, 4)}...${key.value.substring(key.value.length - 4)}`;
                    row.querySelector('.card-notes').value = key.notes || '';
                    row.querySelector('.card-notes').dataset.keyId = key.id;
                    
                    const favoriteBtn = row.querySelector('.favorite-btn');
                    if (key.favorite) favoriteBtn.classList.add('is-favorite');
                    
                    const checkBtn = row.querySelector('.check-btn');
                    const gradientString = provider.gradient || 'from-gray-500 to-gray-600';
                    checkBtn.classList.add('bg-gradient-to-r', ...gradientString.split(' '));

                    // Disable move buttons based on position
                    const moveUpBtn = row.querySelector('.move-up-btn');
                    const moveDownBtn = row.querySelector('.move-down-btn');
                    const siblingKeys = keysInGroup.filter(k => k.favorite === key.favorite);
                    const currentIndexInSubgroup = siblingKeys.findIndex(k => k.id === key.id);
                    if (currentIndexInSubgroup === 0) moveUpBtn.disabled = true;
                    if (currentIndexInSubgroup === siblingKeys.length - 1) moveDownBtn.disabled = true;

                    updateCardStatus(row, 'unknown', 'Ch∆∞a ki·ªÉm tra');
                    tbody.appendChild(row);
                });
                keyGroupsContainer.appendChild(groupDiv);
            });
        }

        function updateCardStatus(row, status, message) {
            const statusDot = row.querySelector('.status-dot');
            const statusText = row.querySelector('.card-status-text');
            statusDot.className = 'status-dot';
            statusDot.classList.add(`status-${status || 'unknown'}`);
            statusText.textContent = message || 'Ch∆∞a ki·ªÉm tra';
        }

        function detectApiKeyType(key) {
            for (const type in API_PROVIDERS) {
                if (API_PROVIDERS[type].regex.test(key)) {
                    if (type === 'openai' && API_PROVIDERS['stability-ai'].regex.test(key)) continue; 
                    return type;
                }
            }
            return 'unknown';
        }

        function validateForm() {
            const key = apiKeyInput.value.trim();
            const name = keyNameInput.value.trim();
            const type = detectApiKeyType(key);
            detectedApiLogo.innerHTML = type !== 'unknown' ? API_PROVIDERS[type].logo : '';
            addKeyBtn.disabled = !(key && name && type !== 'unknown');
        }
        apiKeyInput.addEventListener('input', validateForm);
        keyNameInput.addEventListener('input', validateForm);

        addKeyBtn.addEventListener('click', async () => {
            const newKey = {
                id: crypto.randomUUID(),
                name: keyNameInput.value.trim(),
                value: apiKeyInput.value.trim(),
                type: detectApiKeyType(apiKeyInput.value.trim()),
                notes: '',
                favorite: false,
                order: Date.now(),
                created_at: new Date().toISOString()
            };
            try {
                await apiFetch('/api/keys', { method: 'POST', body: JSON.stringify(newKey) });
                showToast("ƒê√£ th√™m key th√†nh c√¥ng!");
                apiKeyInput.value = ''; keyNameInput.value = '';
                validateForm();
                loadKeys();
            } catch (error) {
                showToast(`L·ªói: ${error.message}`);
            }
        });

        function copyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast('ƒê√£ sao ch√©p v√†o clipboard!');
            } catch (err) {
                showToast('L·ªói: Kh√¥ng th·ªÉ sao ch√©p!');
            }
            document.body.removeChild(textArea);
        }
        
        async function handleMove(keyId, direction) {
            const keyToMove = allLoadedKeys.find(k => k.id === keyId);
            if (!keyToMove) return;

            const siblingKeys = allLoadedKeys
                .filter(k => k.type === keyToMove.type && k.favorite === keyToMove.favorite)
                .sort((a, b) => a.order - b.order);

            const currentIndex = siblingKeys.findIndex(k => k.id === keyId);
            let adjacentIndex = -1;

            if (direction === 'up' && currentIndex > 0) {
                adjacentIndex = currentIndex - 1;
            } else if (direction === 'down' && currentIndex < siblingKeys.length - 1) {
                adjacentIndex = currentIndex + 1;
            }

            if (adjacentIndex !== -1) {
                const adjacentKey = siblingKeys[adjacentIndex];
                
                const tempOrder = keyToMove.order;
                keyToMove.order = adjacentKey.order;
                adjacentKey.order = tempOrder;

                renderKeys(allLoadedKeys);
                showToast('ƒêang l∆∞u thay ƒë·ªïi...');

                try {
                    const update1 = apiFetch(`/api/keys/${keyToMove.id}`, { 
                        method: 'PUT', 
                        body: JSON.stringify({ 
                            order: keyToMove.order,
                            notes: keyToMove.notes || '',
                            favorite: keyToMove.favorite
                        }) 
                    });
                    const update2 = apiFetch(`/api/keys/${adjacentKey.id}`, { 
                        method: 'PUT', 
                        body: JSON.stringify({ 
                            order: adjacentKey.order,
                            notes: adjacentKey.notes || '',
                            favorite: adjacentKey.favorite
                        }) 
                    });
                    
                    await Promise.all([update1, update2]);
                    showToast('ƒê√£ c·∫≠p nh·∫≠t th·ª© t·ª± th√†nh c√¥ng.');
                } catch (error) {
                    showToast(`L·ªói s·∫Øp x·∫øp: ${error.message}. ƒêang ho√†n t√°c...`);
                    adjacentKey.order = keyToMove.order;
                    keyToMove.order = tempOrder;
                    await loadKeys();
                }
            }
        }

        // --- EVENT LISTENERS (ƒê√É S·ª¨A L·ªñI) ---

        keyGroupsContainer.addEventListener('click', async (e) => {
            const row = e.target.closest('.key-row');
            if (!row) return;
            const keyId = row.dataset.id;
            const keyToUpdate = allLoadedKeys.find(k => k.id === keyId);
            if (!keyToUpdate) return;

            if (e.target.closest('.favorite-btn')) {
                const isCurrentlyFavorite = keyToUpdate.favorite;
                keyToUpdate.favorite = !isCurrentlyFavorite;
                renderKeys(allLoadedKeys);
                showToast('ƒêang c·∫≠p nh·∫≠t...');

                try {
                    const payload = {
                        name: keyToUpdate.name,
                        notes: keyToUpdate.notes || '',
                        favorite: keyToUpdate.favorite,
                        order: keyToUpdate.order
                    };
                    await apiFetch(`/api/keys/${keyId}`, { method: 'PUT', body: JSON.stringify(payload) });
                    showToast('ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i y√™u th√≠ch.');
                    await loadKeys();
                } catch (error) {
                    showToast(`L·ªói: ${error.message}`);
                    keyToUpdate.favorite = isCurrentlyFavorite; // Revert on error
                    await loadKeys();
                }
            } else if (e.target.closest('.copy-btn')) {
                copyToClipboard(row.dataset.value);
            } else if (e.target.closest('.delete-btn')) {
                showDeleteConfirmModal(keyId);
            } else if (e.target.closest('.check-btn')) {
                const result = await checkKeyStatus(row, row.dataset.value, row.dataset.type);
                showStatusModal(result);
            } else if (e.target.closest('.move-up-btn')) {
                await handleMove(keyId, 'up');
            } else if (e.target.closest('.move-down-btn')) {
                await handleMove(keyId, 'down');
            }
        });

        keyGroupsContainer.addEventListener('focusout', async (e) => {
            const row = e.target.closest('.key-row');
            if (!row) return;
            const keyId = row.dataset.id;
            const keyToUpdate = allLoadedKeys.find(k => k.id === keyId);
            if (!keyToUpdate) return;
            
            let changed = false;
            let originalValue;

            if (e.target.matches('.card-notes')) {
                const newNotes = e.target.value;
                originalValue = keyToUpdate.notes || '';
                if (newNotes !== originalValue) {
                    keyToUpdate.notes = newNotes;
                    changed = true;
                }
            } else if (e.target.matches('.card-name')) {
                const newName = e.target.textContent.trim();
                originalValue = row.dataset.originalName;
                if (newName && newName !== originalValue) {
                    keyToUpdate.name = newName;
                    row.dataset.originalName = newName;
                    changed = true;
                } else if (!newName) {
                    e.target.textContent = originalValue;
                    keyToUpdate.name = originalValue;
                }
            }

            if (changed) {
                try {
                    const payload = {
                        name: keyToUpdate.name,
                        notes: keyToUpdate.notes || '',
                        favorite: keyToUpdate.favorite,
                        order: keyToUpdate.order
                    };
                    await apiFetch(`/api/keys/${keyId}`, { method: 'PUT', body: JSON.stringify(payload) });
                    showToast('ƒê√£ l∆∞u thay ƒë·ªïi th√†nh c√¥ng.');
                } catch (error) {
                    showToast(`L·ªói c·∫≠p nh·∫≠t: ${error.message}`);
                    await loadKeys(); // Reload to revert failed changes
                }
            }
        });

        // Event listener cho n√∫t "Ki·ªÉm tra t·∫•t c·∫£" c·ªßa nh√≥m
        keyGroupsContainer.addEventListener('click', async (e) => {
            const checkGroupBtn = e.target.closest('.check-group-btn');
            if (!checkGroupBtn) return;

            const groupDiv = checkGroupBtn.closest('.bg-white');
            const groupType = groupDiv.dataset.type;

            setButtonLoading(checkGroupBtn, true);

            const allKeyRowsInGroup = groupDiv.querySelectorAll('.key-row');
            for (const row of allKeyRowsInGroup) {
                await checkKeyStatus(row, row.dataset.value, row.dataset.type);
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            setButtonLoading(checkGroupBtn, false);
            showToast(`ƒê√£ ho√†n t·∫•t ki·ªÉm tra t·∫•t c·∫£ c√°c key c·ªßa nh√≥m ${API_PROVIDERS[groupType]?.name || groupType}.`);
        });

        // --- Logic cho Modal ---
        function showDeleteConfirmModal(keyId) {
            keyIdToDelete = keyId;
            deleteConfirmModal.classList.remove('hidden');
        }

        function hideDeleteConfirmModal() {
            keyIdToDelete = null;
            deleteConfirmModal.classList.add('hidden');
        }

        cancelDeleteBtn.addEventListener('click', hideDeleteConfirmModal);
        confirmDeleteBtn.addEventListener('click', async () => {
            if (!keyIdToDelete) return;
            try {
                await apiFetch(`/api/keys/${keyIdToDelete}`, { method: 'DELETE' });
                showToast('ƒê√£ x√≥a key.');
                loadKeys();
            } catch (error) {
                showToast(`L·ªói x√≥a key: ${error.message}`);
            } finally {
                hideDeleteConfirmModal();
            }
        });

        function showStatusModal(result) {
            const { status, title, message, advice } = result;
            const modalTitle = statusDetailsModal.querySelector('#modal-title');
            const modalStatus = statusDetailsModal.querySelector('#modal-status');
            const modalMessage = statusDetailsModal.querySelector('#modal-message');
            const modalAdvice = statusDetailsModal.querySelector('#modal-advice');
            const modalHeader = statusDetailsModal.querySelector('#modal-header');

            modalHeader.className = 'flex justify-between items-center p-4 border-b rounded-t-lg'; // Reset classes
            modalTitle.className = 'text-xl font-bold'; // Reset classes
            
            modalTitle.textContent = title;
            modalStatus.textContent = title;
            modalMessage.textContent = message;
            modalAdvice.textContent = advice;

            switch(status) {
                case 'active': modalHeader.classList.add('bg-green-100', 'text-green-800'); break;
                case 'limited': modalHeader.classList.add('bg-yellow-100', 'text-yellow-800'); break;
                case 'invalid': modalHeader.classList.add('bg-red-100', 'text-red-800'); break;
                default: modalHeader.classList.add('bg-gray-100', 'text-gray-800');
            }
            statusDetailsModal.classList.remove('hidden');
        }

        closeModalBtn.addEventListener('click', () => statusDetailsModal.classList.add('hidden'));

        function setButtonLoading(btn, isLoading) {
            const btnText = btn.querySelector('.btn-text');
            const loader = btn.querySelector('.loader');
            btn.disabled = isLoading;
            if (isLoading) {
                if(btnText) btnText.classList.add('hidden');
                if(loader) loader.classList.remove('hidden');
            } else {
                if(btnText) btnText.classList.remove('hidden');
                if(loader) loader.classList.add('hidden');
            }
        }
        
        // --- LOGIC KI·ªÇM TRA API (ƒê√É N√ÇNG C·∫§P) ---
        async function checkKeyStatus(row, key, type) {
            const checkBtn = row.querySelector('.check-btn');
            setButtonLoading(checkBtn, true);
            updateCardStatus(row, 'checking', 'ƒêang ki·ªÉm tra...');

            let result;
            try {
                switch (type) {
                    case 'google-ai': result = await checkGoogleKey(key); break;
                    case 'hugging-face': result = await checkHuggingFaceKey(key); break;
                    case 'stability-ai': result = await checkStabilityKey(key); break;
                    case 'openai': result = await checkOpenAIKey(key); break;
                    default: result = { status: 'unknown', title: 'Kh√¥ng x√°c ƒë·ªãnh', message: 'Lo·∫°i API n√†y kh√¥ng h·ªó tr·ª£ ki·ªÉm tra t·ª± ƒë·ªông.', advice: 'Vui l√≤ng ki·ªÉm tra th·ªß c√¥ng t·∫°i trang ch·ªß c·ªßa nh√† cung c·∫•p.' };
                }
            } catch (error) {
                result = { status: 'invalid', title: 'L·ªói K·∫øt N·ªëi', message: error.message, advice: 'Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng c·ªßa b·∫°n v√† th·ª≠ l·∫°i. C√≥ th·ªÉ do CORS ho·∫∑c l·ªói t·ª´ m√°y ch·ªß API.' };
                console.error(`Error checking ${type} key:`, error);
            }
            
            setButtonLoading(checkBtn, false);
            updateCardStatus(row, result.status, result.title);
            return result;
        }
        
        async function getErrorMessage(response) {
            try {
                const errorData = await response.json();
                if (errorData.error && errorData.error.message) return errorData.error.message;
                if (errorData.message) return errorData.message;
                if (errorData.errors) return errorData.errors.map(e => e.message || '').join(', ');
                return JSON.stringify(errorData);
            } catch (e) {
                return `API tr·∫£ v·ªÅ m√£ l·ªói ${response.status} nh∆∞ng kh√¥ng c√≥ n·ªôi dung l·ªói JSON.`;
            }
        }

        async function checkGoogleKey(key) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            if (response.ok) {
                return { status: 'active', title: 'Ho·∫°t ƒë·ªông t·ªët', message: 'Key Google AI (Gemini) h·ª£p l·ªá v√† ƒëang ho·∫°t ƒë·ªông.', advice: 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng key n√†y. H√£y theo d√µi h·∫°n m·ª©c s·ª≠ d·ª•ng tr√™n Google AI Studio.' };
            }
            const errorMessage = await getErrorMessage(response);
            switch(response.status) {
                case 400: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá', message: errorMessage, advice: 'Ki·ªÉm tra l·∫°i key ƒë√£ sao ch√©p ƒë√∫ng ch∆∞a. Key c√≥ th·ªÉ ƒë√£ b·ªã x√≥a ho·∫∑c sai ƒë·ªãnh d·∫°ng.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng ch·ªù m·ªôt l√°t (th∆∞·ªùng l√† 1 ph√∫t) r·ªìi th·ª≠ l·∫°i.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh. Vui l√≤ng ki·ªÉm tra trang tr·∫°ng th√°i c·ªßa Google Cloud.' };
            }
        }

        async function checkStabilityKey(key) {
            const response = await fetch('https://api.stability.ai/v1/user/account', { headers: { 'Authorization': `Bearer ${key}` } });
            if (response.ok) {
                const data = await response.json();
                const credits = data.credits ?? 0;
                if (credits > 0) {
                    return { status: 'active', title: `C√≤n ${credits.toLocaleString('vi-VN')} credits`, message: `Key Stability AI h·ª£p l·ªá. S·ªë d∆∞ credits: ${credits.toLocaleString('vi-VN')}.`, advice: 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng key n√†y. N·∫°p th√™m credits khi c·∫ßn thi·∫øt.' };
                } else {
                    return { status: 'limited', title: 'H·∫øt credits', message: 'Key h·ª£p l·ªá nh∆∞ng ƒë√£ h·∫øt credits. Kh√¥ng th·ªÉ t·∫°o ·∫£nh.', advice: 'Vui l√≤ng n·∫°p th√™m credits v√†o t√†i kho·∫£n DreamStudio ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng.' };
                }
            }
            const errorMessage = await getErrorMessage(response);
            switch(response.status) {
                case 401: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá', message: errorMessage, advice: 'H√£y t·∫°o m·ªôt key m·ªõi tr√™n trang DreamStudio ho·∫∑c ki·ªÉm tra l·∫°i key c·ªßa b·∫°n.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu ki·ªÉm tra. Vui l√≤ng ch·ªù m·ªôt l√°t r·ªìi th·ª≠ l·∫°i.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ c√≥ l·ªói x·∫£y ra t·ª´ ph√≠a Stability AI. Vui l√≤ng th·ª≠ l·∫°i sau.' };
            }
        }

        async function checkHuggingFaceKey(key) {
            const response = await fetch('https://huggingface.co/api/whoami-v2', { headers: { 'Authorization': `Bearer ${key}` } });
            if (response.ok) {
                const data = await response.json();
                return { status: 'active', title: 'Ho·∫°t ƒë·ªông t·ªët', message: `Key h·ª£p l·ªá, thu·ªôc v·ªÅ t√†i kho·∫£n: ${data.name || 'N/A'}.`, advice: 'Key c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng. Ki·ªÉm tra quy·ªÅn (read/write) c·ªßa key n·∫øu g·∫∑p s·ª± c·ªë.' };
            }
            const errorMessage = await getErrorMessage(response);
            switch (response.status) {
                case 401: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá', message: errorMessage, advice: 'H√£y t·∫°o m·ªôt key m·ªõi tr√™n trang c√†i ƒë·∫∑t c·ªßa Hugging Face v√† ƒë·∫£m b·∫£o b·∫°n ƒë√£ sao ch√©p ƒë√∫ng.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng ch·ªù m·ªôt l√°t r·ªìi th·ª≠ l·∫°i.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ c√≥ l·ªói x·∫£y ra t·ª´ ph√≠a Hugging Face. Vui l√≤ng th·ª≠ l·∫°i sau.' };
            }
        }
        
        async function checkOpenAIKey(key) {
            const response = await fetch('https://api.openai.com/v1/models', { headers: { 'Authorization': `Bearer ${key}` } });
            if (response.ok) {
                return { status: 'active', title: 'Ho·∫°t ƒë·ªông t·ªët', message: 'Key OpenAI h·ª£p l·ªá v√† c√≥ quy·ªÅn truy c·∫≠p models.', advice: 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng key n√†y. Theo d√µi h·∫°n m·ª©c v√† thanh to√°n tr√™n trang qu·∫£n tr·ªã c·ªßa OpenAI.' };
            }
            const errorMessage = await getErrorMessage(response);
            switch (response.status) {
                case 401: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá/h·∫øt h·∫°n', message: errorMessage, advice: 'Ki·ªÉm tra l·∫°i key, ho·∫∑c t·∫°o key m·ªõi. C√≥ th·ªÉ key c·ªßa b·∫°n ƒë√£ b·ªã thu h·ªìi ho·∫∑c h·∫øt h·∫°n t√≠n d·ª•ng.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ ƒë·∫°t ƒë·∫øn gi·ªõi h·∫°n y√™u c·∫ßu ho·∫∑c h·∫°n m·ª©c c·ªßa t√†i kho·∫£n. Vui l√≤ng ki·ªÉm tra trang qu·∫£n tr·ªã OpenAI.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng ki·ªÉm tra trang tr·∫°ng th√°i c·ªßa OpenAI.' };
            }
        }

        // --- Logic n√∫t Ki·ªÉm tra t·∫•t c·∫£ (t·ªïng th·ªÉ) ---
        checkAllBtn.addEventListener('click', async () => {
            const checkAllBtnText = document.getElementById('check-all-btn-text');
            const checkAllLoader = document.getElementById('check-all-loader');
            
            checkAllBtn.disabled = true;
            checkAllBtnText.classList.add('hidden');
            checkAllLoader.classList.remove('hidden');

            const allKeyRows = document.querySelectorAll('.key-row');
            for (const row of allKeyRows) {
                await checkKeyStatus(row, row.dataset.value, row.dataset.type);
                await new Promise(resolve => setTimeout(resolve, 300));
            }
            
            checkAllBtn.disabled = false;
            checkAllBtnText.classList.remove('hidden');
            checkAllLoader.classList.add('hidden');
            showToast("ƒê√£ ho√†n t·∫•t ki·ªÉm tra t·∫•t c·∫£ c√°c key.");
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }
    </script>
</body>
</html>
