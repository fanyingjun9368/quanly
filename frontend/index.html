<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√¨nh Qu·∫£n L√Ω API Key</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Be Vietnam Pro', sans-serif; }
        .key-card { transition: all 0.3s ease-in-out; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; }
        .status-active { background-color: #22c55e; }
        .status-invalid { background-color: #ef4444; }
        .status-limited { background-color: #f59e0b; }
        .status-unknown { background-color: #9ca3af; }
        .status-checking { background-color: #3b82f6; animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .toast { visibility: hidden; opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s linear; }
        .toast.show { visibility: visible; opacity: 1; transition: opacity 0.5s linear; }
        .btn-gradient { background-size: 200% auto; transition: background-position 0.5s ease; }
        .btn-gradient:hover { background-position: right center; }
        .loader {
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        .favorite-btn.is-favorite i {
            font-weight: 900; /* Makes the star solid */
            color: #facc15; /* yellow-400 */
        }
        /* Modal Styles */
        .modal-overlay {
            transition: opacity 0.3s ease;
        }
        /* Custom table styles */
        .api-group-table th, .api-group-table td {
            padding: 0.75rem;
            text-align: left;
            vertical-align: top;
        }
        .api-group-table thead th {
            background-color: #f3f4f6; /* gray-100 */
            font-weight: 600;
            color: #374151; /* gray-700 */
        }
        .api-group-table tbody tr:nth-child(even) {
            background-color: #f9fafb; /* gray-50 */
        }
        .api-group-table tbody tr:hover {
            background-color: #eff6ff; /* blue-50 */
        }
        /* Drag and Drop styles */
        .key-row.dragging {
            opacity: 0.5;
            border: 2px dashed #3b82f6; /* blue-500 */
        }
        .key-row.drag-over-top {
            border-top: 2px solid #3b82f6;
        }
        .key-row.drag-over-bottom {
            border-bottom: 2px solid #3b82f6;
        }
    </style>
</head>
<body class="bg-[#fffbbe] text-gray-800">
    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        <header id="app-header" class="flex justify-between items-center mb-10 hidden">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900">Tr√¨nh Qu·∫£n L√Ω API Key</h1>
            <div id="user-info" class="flex items-center gap-4">
                <div class="text-right"><p id="user-name" class="font-semibold text-gray-900"></p></div>
                <img id="user-avatar" class="w-12 h-12 rounded-full" src="" alt="User Avatar">
                <button id="sign-out-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition">ƒêƒÉng xu·∫•t</button>
            </div>
        </header>

        <div id="login-view" class="text-center py-20">
             <h1 class="text-4xl font-bold text-gray-900">TRANG QU·∫¢N L√ù API C·ª¶A TR·ª¢ L√ù PMTL.SITE</h1>
            <p class="text-gray-600 mt-2 mb-8">Ph·ª•ng S·ª± Vi√™n Ph√°p M√¥n T√¢m Linh.</p>
            <div id="gsi-button" class="inline-block"></div>
        </div>

        <main id="app-content" class="hidden">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-10">
                <h2 class="text-xl font-semibold mb-4 text-gray-900">Th√™m Key M·ªõi</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="md:col-span-2">
                        <label for="api-key-input" class="block text-sm font-medium text-gray-600 mb-1">D√°n API Key v√†o ƒë√¢y</label>
                        <div class="relative">
                            <input type="text" id="api-key-input" placeholder="Key s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông nh·∫≠n di·ªán..." class="w-full bg-gray-50 border-gray-300 rounded-lg py-3 pl-4 pr-10 text-gray-900 focus:ring-indigo-500 focus:border-indigo-500 font-mono text-sm">
                            <div id="detected-api-logo" class="absolute inset-y-0 right-0 flex items-center pr-3"></div>
                        </div>
                    </div>
                    <div>
                        <label for="key-name-input" class="block text-sm font-medium text-gray-600 mb-1">T√™n g·ª£i nh·ªõ</label>
                        <input type="text" id="key-name-input" placeholder="V√≠ d·ª•: Project h√¨nh ·∫£nh" class="w-full bg-gray-50 border-gray-300 rounded-lg py-3 px-4 text-gray-900 focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
                <button id="add-key-btn" class="mt-4 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <i class="fas fa-plus-circle mr-2"></i>L∆∞u Key
                </button>
            </div>
            <div>
                <div class="flex flex-col sm:flex-row justify-between items-center mb-6">
                    <h2 class="text-2xl font-semibold text-gray-900 mb-4 sm:mb-0">Danh s√°ch API Keys</h2>
                    <button id="check-all-btn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition flex items-center justify-center gap-2 disabled:bg-gray-400">
                        <i class="fas fa-tasks"></i>
                        <span id="check-all-btn-text">Ki·ªÉm tra t·∫•t c·∫£</span>
                        <div id="check-all-loader" class="loader hidden"></div>
                    </button>
                </div>
                <!-- V√πng hi·ªÉn th·ªã c√°c nh√≥m API key -->
                <div id="key-groups-container" class="space-y-8">
                    <!-- C√°c nh√≥m API key s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
                </div>
            </div>
        </main>
    </div>

    <!-- Template cho h√†ng API key trong b·∫£ng -->
    <template id="key-row-template">
        <tr class="key-row" data-id="" data-value="" data-type="" data-favorite="" data-order="" draggable="true">
            <td class="py-3 px-2 border-b border-gray-200">
                <div class="flex items-center gap-2">
                    <button title="ƒê√°nh d·∫•u y√™u th√≠ch" class="favorite-btn p-1 text-gray-400 hover:text-yellow-400 rounded-lg transition-colors">
                        <i class="far fa-star"></i>
                    </button>
                    <!-- Th√™m contenteditable ƒë·ªÉ s·ª≠a t√™n g·ª£i nh·ªõ -->
                    <span class="card-name text-sm font-medium text-gray-900 break-all" contenteditable="true"></span>
                </div>
            </td>
            <td class="py-3 px-2 border-b border-gray-200">
                <div class="flex items-center gap-2">
                    <p class="card-masked-key font-mono text-xs text-gray-500 break-all flex-grow"></p>
                    <button title="Sao ch√©p key" class="copy-btn p-1 text-gray-400 hover:text-indigo-600 rounded-lg transition-colors">
                        <i class="far fa-copy"></i>
                    </button>
                </div>
            </td>
            <td class="py-3 px-2 border-b border-gray-200">
                <div class="flex items-center gap-1">
                    <div class="status-dot flex-shrink-0"></div>
                    <p class="card-status-text text-xs text-gray-600 flex-grow">Ch∆∞a ki·ªÉm tra</p>
                </div>
            </td>
            <td class="py-3 px-2 border-b border-gray-200">
                <textarea class="card-notes w-full bg-gray-50 p-1 rounded-md text-xs text-gray-800 resize-none border border-gray-200 focus:ring-1 focus:ring-indigo-500" rows="1" placeholder="Th√™m ghi ch√∫..."></textarea>
            </td>
            <td class="py-3 px-2 border-b border-gray-200 text-right">
                <div class="flex items-center justify-end space-x-1">
                    <!-- N√∫t di chuy·ªÉn l√™n/xu·ªëng ƒë√£ b·ªã lo·∫°i b·ªè -->
                    <button class="check-btn btn-gradient text-white text-xs font-bold py-1 px-2 rounded-lg transition duration-300 flex items-center gap-1"><i class="fas fa-sync-alt"></i><span class="btn-text">Ki·ªÉm tra</span><div class="loader hidden"></div></button>
                    <button class="delete-btn bg-gray-200 hover:bg-red-200 text-gray-700 hover:text-red-800 text-xs font-bold py-1 px-2 rounded-lg transition"><i class="fas fa-trash"></i></button>
                </div>
            </td>
        </tr>
    </template>

    <!-- Toast th√¥ng b√°o nhanh -->
    <div id="toast" class="toast fixed bottom-5 left-1/2 -translate-x-1/2 bg-gray-800 text-white py-2 px-5 rounded-lg shadow-lg"></div>

    <!-- Modal X√°c nh·∫≠n X√≥a -->
    <div id="delete-confirm-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-bold text-gray-900 mb-4">X√°c nh·∫≠n x√≥a</h3>
            <p class="text-gray-600 mb-6">B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a API key n√†y kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.</p>
            <div class="flex justify-end space-x-4">
                <button id="cancel-delete-btn" class="py-2 px-4 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition">H·ªßy</button>
                <button id="confirm-delete-btn" class="py-2 px-4 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">X√≥a</button>
            </div>
        </div>
    </div>
    
    <!-- Modal Chi ti·∫øt Tr·∫°ng th√°i API -->
    <div id="status-details-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md">
            <div id="modal-header" class="flex justify-between items-center p-4 border-b rounded-t-lg">
                <h3 id="modal-title" class="text-xl font-bold">Chi ti·∫øt Tr·∫°ng th√°i API</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
            </div>
            <div class="p-5">
                <div class="mb-4">
                    <p class="font-semibold text-gray-800">Tr·∫°ng th√°i:</p>
                    <p id="modal-status" class="text-gray-700 p-2 rounded-md font-medium"></p>
                </div>
                <div class="mb-4">
                    <p class="font-semibold text-gray-800">Th√¥ng ƒëi·ªáp t·ª´ API (g·ªëc):</p>
                    <p id="modal-message" class="text-sm text-gray-700 bg-gray-100 p-3 rounded-md font-mono"></p>
                </div>
                <div>
                    <p class="font-semibold text-gray-800">üí° Khuy·∫øn ngh·ªã:</p>
                    <p id="modal-advice" class="text-gray-600"></p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        // --- C·∫•u h√¨nh ---
        const GOOGLE_CLIENT_ID = '833528835955-t7pai7q2tb836dqggme3h3560n58s6au.apps.googleusercontent.com';
        const BACKEND_URL = 'https://quanly-backen.onrender.com';
        let idToken = null;
        let keyIdToDelete = null;
        let allLoadedKeys = []; // Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ t·∫•t c·∫£ c√°c key ƒë√£ t·∫£i

        // Bi·∫øn to√†n c·ª•c cho k√©o th·∫£
        let draggedRow = null;

        const API_PROVIDERS = {
            'google-ai': { name: 'Google AI (Gemini)', regex: /^AIzaSy[A-Za-z0-9_-]{33}$/, logo: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-blue-500"><path d="M21.35,11.1H12.18V13.83H18.69C18.36,17.64 15.19,19.27 12.19,19.27C8.36,19.27 5,16.25 5,12C5,7.9 8.2,4.73 12.18,4.73C15.29,4.73 17.1,6.7 17.1,6.7L19,4.72C19,4.72 16.56,2 12.18,2C6.42,2 2.03,6.8 2.03,12C2.03,17.05 6.16,22 12.18,22C17.6,22 21.54,18.33 21.54,12.81C21.54,11.76 21.45,11.44 21.35,11.1Z"/></svg>`, gradient: 'from-blue-500 to-green-500' },
            'hugging-face': { name: 'Hugging Face', regex: /^hf_[A-Za-z0-9]{30,}/, logo: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-yellow-500"><path d="M20.25 14.183C20.25 13.202 19.431 12.383 18.45 12.383C17.469 12.383 16.65 13.202 16.65 14.183C16.65 15.164 17.469 15.983 18.45 15.983C19.431 15.983 20.25 15.164 20.25 14.183ZM15.15 14.183C15.15 13.202 14.331 12.383 13.35 12.383C12.369 12.383 11.55 13.202 11.55 14.183C11.55 15.164 12.369 15.983 13.35 15.983C14.331 15.983 15.15 15.164 15.15 14.183ZM12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22C6.477 22 2 17.523 2 12C2 6.477 6.477 2 12 2ZM12 4C7.582 4 4 7.582 4 12C4 16.418 7.582 20 12 20C16.418 20 20 16.418 20 12C20 7.582 16.418 4 12 4ZM8.85 14.183C8.85 13.202 8.031 12.383 7.05 12.383C6.069 12.383 5.25 13.202 5.25 14.183C5.25 15.164 6.069 15.983 7.05 15.983C8.031 15.983 8.85 15.164 8.85 14.183Z"/></svg>`, gradient: 'from-yellow-500 to-orange-500' },
            'stability-ai': { name: 'Stability AI', regex: /^sk-[A-Za-z0-9]{40,}/, logo: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 text-purple-500"><path d="M12 2L9.429 9.429 2 12l7.429 2.571L12 22l2.571-7.429L22 12l-7.429-2.571z"/></svg>`, gradient: 'from-purple-500 to-pink-500' },
            'openai': { name: 'OpenAI', regex: /^sk-[A-Za-z0-9]{20,}/, logo: `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 text-teal-500"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" /></svg>`, gradient: 'from-teal-500 to-cyan-500' },
        };

        // --- Logic Giao ti·∫øp Backend ---
        async function apiFetch(endpoint, options = {}) {
            if (!idToken) throw new Error("User not authenticated");
            const headers = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${idToken}`, ...options.headers };
            let response;
            try {
                response = await fetch(`${BACKEND_URL}${endpoint}`, { ...options, headers });
            } catch (networkError) {
                console.error("Network error:", networkError);
                throw new Error("L·ªói m·∫°ng. Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn m√°y ch·ªß.");
            }
            if (!response.ok) {
                let errorMsg = `L·ªói HTTP! M√£: ${response.status}`;
                try {
                    const errorData = await response.json();
                    errorMsg = errorData.error || JSON.stringify(errorData);
                } catch (e) {
                    errorMsg = `L·ªói m√°y ch·ªß (M√£: ${response.status}). Kh√¥ng th·ªÉ ƒë·ªçc ph·∫£n h·ªìi.`;
                }
                throw new Error(errorMsg);
            }
            if (response.status === 204) return null;
            try {
                return await response.json();
            } catch (e) {
                if (e instanceof SyntaxError) {
                    console.error("Failed to parse JSON response. Backend might be misconfigured.", e);
                    throw new Error("L·ªói giao ti·∫øp: Backend tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i c·∫•u h√¨nh BACKEND_URL.");
                }
                throw e;
            }
        }

        // --- X√°c th·ª±c Google & Qu·∫£n l√Ω UI ---
        function decodeJwtPayload(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
                return JSON.parse(jsonPayload);
            } catch (e) {
                console.error("Error decoding JWT", e);
                return null;
            }
        }

        // H√†m kh·ªüi t·∫°o ·ª©ng d·ª•ng sau khi x√°c th·ª±c th√†nh c√¥ng
        function initializeAuthenticatedApp(token) {
            idToken = token;
            const userProfile = decodeJwtPayload(idToken);
            if (!userProfile) {
                showToast("Kh√¥ng th·ªÉ gi·∫£i m√£ th√¥ng tin ng∆∞·ªùi d√πng.");
                return;
            }
            document.getElementById('user-name').textContent = userProfile.name;
            document.getElementById('user-avatar').src = userProfile.picture;
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('app-header').classList.remove('hidden');
            document.getElementById('app-content').classList.remove('hidden');
            loadKeys();
        }

        window.onload = function () {
            if (GOOGLE_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID' || BACKEND_URL === 'YOUR_RENDER_BACKEND_URL') {
                document.getElementById('login-view').innerHTML = `<h2 class="text-2xl text-red-500 font-bold">L·ªói C·∫•u H√¨nh Frontend</h2><p class="text-gray-600 mt-2">Vui l√≤ng ƒëi·ªÅn GOOGLE_CLIENT_ID v√† BACKEND_URL trong t·ªáp HTML.</p>`;
                return;
            }

            // Ki·ªÉm tra token ƒë√£ l∆∞u trong localStorage
            const storedIdToken = localStorage.getItem('idToken');
            if (storedIdToken) {
                initializeAuthenticatedApp(storedIdToken);
            } else {
                // N·∫øu kh√¥ng c√≥ token, kh·ªüi t·∫°o Google Sign-In button
                google.accounts.id.initialize({ client_id: GOOGLE_CLIENT_ID, callback: handleCredentialResponse, auto_select: true }); // Th√™m auto_select
                google.accounts.id.renderButton(document.getElementById("gsi-button"), { theme: "outline", size: "large", text: "signin_with", shape: "rectangular" });
            }
        };

        function handleCredentialResponse(response) {
            // L∆∞u token v√†o localStorage sau khi ƒëƒÉng nh·∫≠p th√†nh c√¥ng
            localStorage.setItem('idToken', response.credential);
            initializeAuthenticatedApp(response.credential);
        }

        document.getElementById('sign-out-btn').addEventListener('click', () => {
            idToken = null;
            localStorage.removeItem('idToken'); // X√≥a token khi ƒëƒÉng xu·∫•t
            google.accounts.id.disableAutoSelect(); // T·∫Øt t·ª± ƒë·ªông ch·ªçn t√†i kho·∫£n
            document.getElementById('login-view').classList.remove('hidden');
            document.getElementById('app-header').classList.add('hidden');
            document.getElementById('app-content').classList.add('hidden');
            // Render l·∫°i n√∫t ƒëƒÉng nh·∫≠p ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ ƒëƒÉng nh·∫≠p l·∫°i
            google.accounts.id.initialize({ client_id: GOOGLE_CLIENT_ID, callback: handleCredentialResponse, auto_select: true });
            google.accounts.id.renderButton(document.getElementById("gsi-button"), { theme: "outline", size: "large", text: "signin_with", shape: "rectangular" });
        });

        // --- Logic CRUD & Hi·ªÉn th·ªã ---
        const apiKeyInput = document.getElementById('api-key-input');
        const keyNameInput = document.getElementById('key-name-input');
        const addKeyBtn = document.getElementById('add-key-btn');
        const keyGroupsContainer = document.getElementById('key-groups-container');
        const detectedApiLogo = document.getElementById('detected-api-logo');
        const keyRowTemplate = document.getElementById('key-row-template');
        const checkAllBtn = document.getElementById('check-all-btn');
        
        const deleteConfirmModal = document.getElementById('delete-confirm-modal');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        const cancelDeleteBtn = document.getElementById('cancel-delete-btn');

        const statusDetailsModal = document.getElementById('status-details-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');

        async function loadKeys() {
            try {
                const keys = await apiFetch('/api/keys');
                // ƒê·∫£m b·∫£o t·∫•t c·∫£ c√°c key ƒë·ªÅu c√≥ thu·ªôc t√≠nh 'order' ƒë·ªÉ s·∫Øp x·∫øp nh·∫•t qu√°n
                allLoadedKeys = keys.map(key => ({
                    ...key,
                    order: key.order ?? new Date(key.created_at).getTime() // M·∫∑c ƒë·ªãnh l√† timestamp c·ªßa created_at n·∫øu order b·ªã thi·∫øu
                }));
                renderKeys(allLoadedKeys); // Truy·ªÅn c√°c key ƒë√£ x·ª≠ l√Ω ƒë·ªÉ render
            } catch (error) {
                showToast(`L·ªói t·∫£i keys: ${error.message}`);
            }
        }

        function renderKeys(keysToRender) {
            keyGroupsContainer.innerHTML = ''; // X√≥a n·ªôi dung c≈©

            if (!keysToRender || keysToRender.length === 0) {
                keyGroupsContainer.innerHTML = `<p class="text-gray-500 col-span-full text-center">B·∫°n ch∆∞a c√≥ API key n√†o.</p>`;
                return;
            }

            // Nh√≥m c√°c key theo lo·∫°i
            const groupedKeys = keysToRender.reduce((acc, key) => {
                const type = key.type || 'unknown';
                if (!acc[type]) {
                    acc[type] = [];
                }
                acc[type].push(key);
                return acc;
            }, {});

            // S·∫Øp x·∫øp c√°c lo·∫°i nh√† cung c·∫•p ƒë·ªÉ hi·ªÉn th·ªã nh·∫•t qu√°n
            const sortedProviderTypes = Object.keys(API_PROVIDERS).filter(type => groupedKeys[type]);
            const unknownKeys = groupedKeys['unknown'];
            if (unknownKeys) {
                sortedProviderTypes.push('unknown'); // Th√™m c√°c key kh√¥ng x√°c ƒë·ªãnh ·ªü cu·ªëi
            }

            sortedProviderTypes.forEach(type => {
                const provider = API_PROVIDERS[type] || { name: 'Lo·∫°i kh√¥ng x√°c ƒë·ªãnh', logo: '' };
                // S·∫Øp x·∫øp trong m·ªói nh√≥m: y√™u th√≠ch (gi·∫£m d·∫ßn), sau ƒë√≥ ƒë·∫øn order (tƒÉng d·∫ßn)
                const keysInGroup = groupedKeys[type].sort((a, b) => (b.favorite ? 1 : 0) - (a.favorite ? 1 : 0) || a.order - b.order);

                const groupDiv = document.createElement('div');
                groupDiv.className = 'bg-white p-6 rounded-xl shadow-lg';
                groupDiv.dataset.type = type; // Th√™m data-type v√†o div nh√≥m

                groupDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-gray-900 flex items-center gap-2">
                            ${provider.logo}
                            <span>${provider.name} Keys</span>
                        </h3>
                        <button class="check-group-btn w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition flex items-center justify-center gap-2 disabled:bg-gray-400">
                            <i class="fas fa-sync-alt"></i>
                            <span class="btn-text">Ki·ªÉm tra t·∫•t c·∫£ ${provider.name}</span>
                            <div class="loader hidden"></div>
                        </button>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 api-group-table">
                            <thead>
                                <tr>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">T√™n g·ª£i nh·ªõ</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">API Key</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/6">Tr·∫°ng th√°i</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">Ghi ch√∫</th>
                                    <th class="py-3 px-2 text-xs font-medium text-gray-500 uppercase tracking-wider w-1/12 text-right">H√†nh ƒë·ªông</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- C√°c h√†ng key s·∫Ω ƒë∆∞·ª£c th√™m v√†o ƒë√¢y -->
                            </tbody>
                        </table>
                    </div>
                `;
                
                const tbody = groupDiv.querySelector('tbody');
                keysInGroup.forEach(key => {
                    const row = keyRowTemplate.content.cloneNode(true).firstElementChild;
                    row.dataset.id = key.id;
                    row.dataset.value = key.value;
                    row.dataset.type = key.type;
                    row.dataset.favorite = String(key.favorite);
                    row.dataset.order = String(key.order); // L∆∞u tr·ªØ order trong dataset

                    const nameSpan = row.querySelector('.card-name');
                    nameSpan.textContent = key.name;
                    nameSpan.contentEditable = true; // Cho ph√©p s·ª≠a t√™n g·ª£i nh·ªõ
                    row.dataset.originalName = key.name; // L∆∞u t√™n g·ªëc ƒë·ªÉ so s√°nh khi s·ª≠a

                    row.querySelector('.card-masked-key').textContent = `${key.value.substring(0, 4)}...${key.value.substring(key.value.length - 4)}`;
                    const notesEl = row.querySelector('.card-notes');
                    notesEl.value = key.notes || '';
                    notesEl.dataset.keyId = key.id;
                    const checkBtn = row.querySelector('.check-btn');
                    const favoriteBtn = row.querySelector('.favorite-btn');
                    
                    if (key.favorite) {
                        favoriteBtn.classList.add('is-favorite');
                    }
                    
                    const gradientString = provider.gradient || 'from-gray-500 to-gray-600';
                    checkBtn.classList.add('bg-gradient-to-r', ...gradientString.split(' '));

                    updateCardStatus(row, 'unknown', 'Ch∆∞a ki·ªÉm tra');
                    tbody.appendChild(row);
                });
                keyGroupsContainer.appendChild(groupDiv);
            });
        }

        function updateCardStatus(row, status, message) {
            const statusDot = row.querySelector('.status-dot');
            const statusText = row.querySelector('.card-status-text');
            statusDot.className = 'status-dot';
            statusDot.classList.add(`status-${status || 'unknown'}`);
            statusText.textContent = message || 'Ch∆∞a ki·ªÉm tra';
        }

        function detectApiKeyType(key) {
            for (const type in API_PROVIDERS) {
                if (API_PROVIDERS[type].regex.test(key)) {
                    // X·ª≠ l√Ω ƒë·∫∑c bi·ªát cho OpenAI vs Stability AI n·∫øu regex c·ªßa ch√∫ng tr√πng l·∫∑p
                    if (type === 'openai' && API_PROVIDERS['stability-ai'].regex.test(key)) continue; 
                    return type;
                }
            }
            return 'unknown';
        }

        function validateForm() {
            const key = apiKeyInput.value.trim();
            const name = keyNameInput.value.trim();
            const type = detectApiKeyType(key);
            detectedApiLogo.innerHTML = type !== 'unknown' ? API_PROVIDERS[type].logo : '';
            addKeyBtn.disabled = !(key && name && type !== 'unknown');
        }
        apiKeyInput.addEventListener('input', validateForm);
        keyNameInput.addEventListener('input', validateForm);

        addKeyBtn.addEventListener('click', async () => {
            const newKey = {
                id: crypto.randomUUID(),
                name: keyNameInput.value.trim(),
                value: apiKeyInput.value.trim(),
                type: detectApiKeyType(apiKeyInput.value.trim()),
                notes: '',
                favorite: false,
                order: Date.now(), // Th√™m thu·ªôc t√≠nh order khi t·∫°o key m·ªõi
                created_at: new Date().toISOString()
            };
            try {
                await apiFetch('/api/keys', { method: 'POST', body: JSON.stringify(newKey) });
                showToast("ƒê√£ th√™m key th√†nh c√¥ng!");
                apiKeyInput.value = ''; keyNameInput.value = '';
                validateForm();
                loadKeys();
            } catch (error) {
                showToast(`L·ªói: ${error.message}`);
            }
        });

        function copyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            textArea.style.padding = '0';
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            textArea.style.background = 'transparent';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showToast('ƒê√£ sao ch√©p v√†o clipboard!');
                } else {
                    showToast('L·ªói: Kh√¥ng th·ªÉ sao ch√©p!');
                }
            } catch (err) {
                showToast('L·ªói: Kh√¥ng th·ªÉ sao ch√©p!');
                console.error('L·ªói khi sao ch√©p:', err);
            }
            document.body.removeChild(textArea);
        }
        
        // Event listener cho c√°c h√†nh ƒë·ªông trong c√°c h√†ng key
        keyGroupsContainer.addEventListener('click', async (e) => {
            const row = e.target.closest('.key-row');
            if (!row) return;

            const keyId = row.dataset.id;
            
            if (e.target.closest('.favorite-btn')) {
                const isCurrentlyFavorite = row.dataset.favorite === 'true';
                try {
                    // C·∫≠p nh·∫≠t key trong allLoadedKeys tr∆∞·ªõc khi g·ª≠i l√™n backend
                    const keyToUpdate = allLoadedKeys.find(k => k.id === keyId);
                    if (keyToUpdate) {
                        keyToUpdate.favorite = !isCurrentlyFavorite;
                        await apiFetch(`/api/keys/${keyId}`, { method: 'PUT', body: JSON.stringify({ favorite: keyToUpdate.favorite, notes: keyToUpdate.notes, order: keyToUpdate.order }) });
                        loadKeys(); // T·∫£i l·∫°i ƒë·ªÉ ph·∫£n √°nh thay ƒë·ªïi tr·∫°ng th√°i y√™u th√≠ch v√† s·∫Øp x·∫øp l·∫°i
                    }
                } catch (error) {
                    showToast(`L·ªói c·∫≠p nh·∫≠t y√™u th√≠ch: ${error.message}`);
                }
            } else if (e.target.closest('.copy-btn')) {
                copyToClipboard(row.dataset.value);
            } else if (e.target.closest('.delete-btn')) {
                showDeleteConfirmModal(keyId);
            } else if (e.target.closest('.check-btn')) {
                const result = await checkKeyStatus(row, row.dataset.value, row.dataset.type);
                showStatusModal(result);
            }
            // N√∫t di chuy·ªÉn l√™n/xu·ªëng ƒë√£ b·ªã lo·∫°i b·ªè, logic n√†y c≈©ng b·ªã lo·∫°i b·ªè
        });

        // Event listener cho n√∫t "Ki·ªÉm tra t·∫•t c·∫£" c·ªßa nh√≥m
        keyGroupsContainer.addEventListener('click', async (e) => {
            const checkGroupBtn = e.target.closest('.check-group-btn');
            if (!checkGroupBtn) return;

            const groupDiv = checkGroupBtn.closest('.bg-white');
            const groupType = groupDiv.dataset.type;

            setButtonLoading(checkGroupBtn, true);

            const allKeyRowsInGroup = groupDiv.querySelectorAll('.key-row');
            for (const row of allKeyRowsInGroup) {
                await checkKeyStatus(row, row.dataset.value, row.dataset.type);
                await new Promise(resolve => setTimeout(resolve, 300)); // Th√™m ƒë·ªô tr·ªÖ nh·ªè ƒë·ªÉ tr√°nh rate limit
            }
            
            setButtonLoading(checkGroupBtn, false);
            showToast(`ƒê√£ ho√†n t·∫•t ki·ªÉm tra t·∫•t c·∫£ c√°c key c·ªßa nh√≥m ${API_PROVIDERS[groupType]?.name || groupType}.`);
        });

        // --- Logic cho Modal ---
        function showDeleteConfirmModal(keyId) {
            keyIdToDelete = keyId;
            deleteConfirmModal.classList.remove('hidden');
        }

        function hideDeleteConfirmModal() {
            keyIdToDelete = null;
            deleteConfirmModal.classList.add('hidden');
        }

        cancelDeleteBtn.addEventListener('click', hideDeleteConfirmModal);
        confirmDeleteBtn.addEventListener('click', async () => {
            if (!keyIdToDelete) return;
            try {
                await apiFetch(`/api/keys/${keyIdToDelete}`, { method: 'DELETE' });
                showToast('ƒê√£ x√≥a key.');
                loadKeys();
            } catch (error) {
                showToast(`L·ªói x√≥a key: ${error.message}`);
            } finally {
                hideDeleteConfirmModal();
            }
        });

        function showStatusModal(result) {
            const { status, title, message, advice } = result;
            const modalTitle = statusDetailsModal.querySelector('#modal-title');
            const modalStatus = statusDetailsModal.querySelector('#modal-status');
            const modalMessage = statusDetailsModal.querySelector('#modal-message');
            const modalAdvice = statusDetailsModal.querySelector('#modal-advice');
            const modalHeader = statusDetailsModal.querySelector('#modal-header');

            modalHeader.classList.remove('bg-green-100', 'bg-yellow-100', 'bg-red-100', 'bg-gray-100', 'text-green-800', 'text-yellow-800', 'text-red-800', 'text-gray-800');
            modalTitle.classList.remove('text-green-800', 'text-yellow-800', 'text-red-800', 'text-gray-800');
            
            modalTitle.textContent = title;
            modalStatus.textContent = title;
            modalMessage.textContent = message;
            modalAdvice.textContent = advice;

            switch(status) {
                case 'active':
                    modalHeader.classList.add('bg-green-100', 'text-green-800');
                    modalTitle.classList.add('text-green-800');
                    break;
                case 'limited':
                    modalHeader.classList.add('bg-yellow-100', 'text-yellow-800');
                    modalTitle.classList.add('text-yellow-800');
                    break;
                case 'invalid':
                    modalHeader.classList.add('bg-red-100', 'text-red-800');
                    modalTitle.classList.add('text-red-800');
                    break;
                default:
                    modalHeader.classList.add('bg-gray-100', 'text-gray-800');
                    modalTitle.classList.add('text-gray-800');
            }
            statusDetailsModal.classList.remove('hidden');
        }

        closeModalBtn.addEventListener('click', () => statusDetailsModal.classList.add('hidden'));

        // Event listener cho textarea ghi ch√∫ v√† span t√™n g·ª£i nh·ªõ khi m·∫•t focus (l∆∞u thay ƒë·ªïi)
        keyGroupsContainer.addEventListener('focusout', async (e) => {
            // Logic l∆∞u ghi ch√∫
            if (e.target.closest('.card-notes')) {
                const notesTextarea = e.target.closest('.card-notes');
                const keyId = notesTextarea.dataset.keyId;
                const newNotes = notesTextarea.value;
                try {
                    // C·∫≠p nh·∫≠t key trong allLoadedKeys tr∆∞·ªõc khi g·ª≠i l√™n backend
                    const keyToUpdate = allLoadedKeys.find(k => k.id === keyId);
                    if (keyToUpdate) {
                        keyToUpdate.notes = newNotes;
                        await apiFetch(`/api/keys/${keyId}`, { method: 'PUT', body: JSON.stringify({ notes: newNotes, favorite: keyToUpdate.favorite, order: keyToUpdate.order }) });
                        showToast('ƒê√£ l∆∞u ghi ch√∫.');
                    }
                } catch (error) {
                    showToast(`L·ªói l∆∞u ghi ch√∫: ${error.message}`);
                }
            }
            // Logic l∆∞u t√™n g·ª£i nh·ªõ
            else if (e.target.closest('.card-name')) {
                const nameSpan = e.target.closest('.card-name');
                const row = nameSpan.closest('.key-row');
                const keyId = row.dataset.id;
                const newName = nameSpan.textContent.trim();
                // Ch·ªâ g·ª≠i y√™u c·∫ßu n·∫øu t√™n th·ª±c s·ª± thay ƒë·ªïi
                if (newName && newName !== row.dataset.originalName) {
                    try {
                        // C·∫≠p nh·∫≠t key trong allLoadedKeys tr∆∞·ªõc khi g·ª≠i l√™n backend
                        const keyToUpdate = allLoadedKeys.find(k => k.id === keyId);
                        if (keyToUpdate) {
                            keyToUpdate.name = newName;
                            await apiFetch(`/api/keys/${keyId}`, { method: 'PUT', body: JSON.stringify({ name: newName, notes: keyToUpdate.notes, favorite: keyToUpdate.favorite, order: keyToUpdate.order }) });
                            row.dataset.originalName = newName; // C·∫≠p nh·∫≠t t√™n g·ªëc ƒë·ªÉ so s√°nh trong t∆∞∆°ng lai
                            showToast('ƒê√£ c·∫≠p nh·∫≠t t√™n g·ª£i nh·ªõ.');
                        }
                    } catch (error) {
                        showToast(`L·ªói c·∫≠p nh·∫≠t t√™n: ${error.message}`);
                        // Ho√†n nguy√™n v·ªÅ t√™n g·ªëc n·∫øu l∆∞u th·∫•t b·∫°i
                        nameSpan.textContent = row.dataset.originalName;
                    }
                }
            }
        });

        function setButtonLoading(btn, isLoading) {
            const btnText = btn.querySelector('.btn-text');
            const loader = btn.querySelector('.loader');
            btn.disabled = isLoading;
            if (isLoading) {
                if(btnText) btnText.classList.add('hidden');
                if(loader) loader.classList.remove('hidden');
            } else {
                if(btnText) btnText.classList.remove('hidden');
                if(loader) loader.classList.add('hidden');
            }
        }
        
        // --- LOGIC KI·ªÇM TRA API (ƒê√É N√ÇNG C·∫§P) ---
        async function checkKeyStatus(row, key, type) {
            const checkBtn = row.querySelector('.check-btn');
            setButtonLoading(checkBtn, true);
            updateCardStatus(row, 'checking', 'ƒêang ki·ªÉm tra...');

            let result;
            try {
                switch (type) {
                    case 'google-ai': result = await checkGoogleKey(key); break;
                    case 'hugging-face': result = await checkHuggingFaceKey(key); break;
                    case 'stability-ai': result = await checkStabilityKey(key); break;
                    case 'openai': result = await checkOpenAIKey(key); break;
                    default: result = { status: 'unknown', title: 'Kh√¥ng x√°c ƒë·ªãnh', message: 'Lo·∫°i API n√†y kh√¥ng h·ªó tr·ª£ ki·ªÉm tra t·ª± ƒë·ªông.', advice: 'Vui l√≤ng ki·ªÉm tra th·ªß c√¥ng t·∫°i trang ch·ªß c·ªßa nh√† cung c·∫•p.' };
                }
            } catch (error) {
                result = { status: 'invalid', title: 'L·ªói K·∫øt N·ªëi', message: error.message, advice: 'Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng c·ªßa b·∫°n v√† th·ª≠ l·∫°i. C√≥ th·ªÉ do CORS ho·∫∑c l·ªói t·ª´ m√°y ch·ªß API.' };
                console.error(`Error checking ${type} key:`, error);
            }
            
            setButtonLoading(checkBtn, false);
            updateCardStatus(row, result.status, result.title);
            return result;
        }
        
        // Helper function to parse error response
        async function getErrorMessage(response) {
            try {
                const errorData = await response.json();
                if (errorData.error && errorData.error.message) return errorData.error.message;
                if (errorData.message) return errorData.message;
                if (errorData.errors) return errorData.errors.map(e => e.message || '').join(', ');
                return JSON.stringify(errorData);
            } catch (e) {
                return `API tr·∫£ v·ªÅ m√£ l·ªói ${response.status} nh∆∞ng kh√¥ng c√≥ n·ªôi dung l·ªói JSON.`;
            }
        }

        async function checkGoogleKey(key) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            if (response.ok) {
                return { status: 'active', title: 'Ho·∫°t ƒë·ªông t·ªët', message: 'Key Google AI (Gemini) h·ª£p l·ªá v√† ƒëang ho·∫°t ƒë·ªông.', advice: 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng key n√†y. H√£y theo d√µi h·∫°n m·ª©c s·ª≠ d·ª•ng tr√™n Google AI Studio.' };
            }
            const errorMessage = await getErrorMessage(response);
            switch(response.status) {
                case 400: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá', message: errorMessage, advice: 'Ki·ªÉm tra l·∫°i key ƒë√£ sao ch√©p ƒë√∫ng ch∆∞a. Key c√≥ th·ªÉ ƒë√£ b·ªã x√≥a ho·∫∑c sai ƒë·ªãnh d·∫°ng.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng ch·ªù m·ªôt l√°t (th∆∞·ªùng l√† 1 ph√∫t) r·ªìi th·ª≠ l·∫°i.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh. Vui l√≤ng ki·ªÉm tra trang tr·∫°ng th√°i c·ªßa Google Cloud.' };
            }
        }

        async function checkStabilityKey(key) {
            const response = await fetch('https://api.stability.ai/v1/user/account', { headers: { 'Authorization': `Bearer ${key}` } });
            
            if (response.ok) {
                const data = await response.json();
                const credits = data.credits ?? 0;
                
                if (credits > 0) {
                    return { 
                        status: 'active', 
                        title: `C√≤n ${credits.toLocaleString('vi-VN')} credits`, 
                        message: `Key Stability AI h·ª£p l·ªá. S·ªë d∆∞ credits: ${credits.toLocaleString('vi-VN')}.`, 
                        advice: 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng key n√†y. N·∫°p th√™m credits khi c·∫ßn thi·∫øt.' 
                    };
                } else {
                    return { 
                        status: 'limited', 
                        title: 'H·∫øt credits', 
                        message: 'Key h·ª£p l·ªá nh∆∞ng ƒë√£ h·∫øt credits. Kh√¥ng th·ªÉ t·∫°o ·∫£nh.', 
                        advice: 'Vui l√≤ng n·∫°p th√™m credits v√†o t√†i kho·∫£n DreamStudio ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng.' 
                    };
                }
            }
            
            const errorMessage = await getErrorMessage(response);
            switch(response.status) {
                case 401: 
                    return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá', message: errorMessage, advice: 'H√£y t·∫°o m·ªôt key m·ªõi tr√™n trang DreamStudio ho·∫∑c ki·ªÉm tra l·∫°i key c·ªßa b·∫°n.' };
                case 429: 
                    return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu ki·ªÉm tra. Vui l√≤ng ch·ªù m·ªôt l√°t r·ªìi th·ª≠ l·∫°i.' };
                default: 
                    return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ c√≥ l·ªói x·∫£y ra t·ª´ ph√≠a Stability AI. Vui l√≤ng th·ª≠ l·∫°i sau.' };
            }
        }

        async function checkHuggingFaceKey(key) {
            const response = await fetch('https://huggingface.co/api/whoami-v2', { headers: { 'Authorization': `Bearer ${key}` } });
            if (response.ok) {
                const data = await response.json();
                return { status: 'active', title: 'Ho·∫°t ƒë·ªông t·ªët', message: `Key h·ª£p l·ªá, thu·ªôc v·ªÅ t√†i kho·∫£n: ${data.name || 'N/A'}.`, advice: 'Key c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng. Ki·ªÉm tra quy·ªÅn (read/write) c·ªßa key n·∫øu g·∫∑p s·ª± c·ªë.' };
            }
            const errorMessage = await getErrorMessage(response);
            switch (response.status) {
                case 401: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá', message: errorMessage, advice: 'H√£y t·∫°o m·ªôt key m·ªõi tr√™n trang c√†i ƒë·∫∑t c·ªßa Hugging Face v√† ƒë·∫£m b·∫£o b·∫°n ƒë√£ sao ch√©p ƒë√∫ng.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng ch·ªù m·ªôt l√°t r·ªìi th·ª≠ l·∫°i.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ c√≥ l·ªói x·∫£y ra t·ª´ ph√≠a Hugging Face. Vui l√≤ng th·ª≠ l·∫°i sau.' };
            }
        }
        
        async function checkOpenAIKey(key) {
            const response = await fetch('https://api.openai.com/v1/models', { headers: { 'Authorization': `Bearer ${key}` } });
            if (response.ok) {
                return { status: 'active', title: 'Ho·∫°t ƒë·ªông t·ªët', message: 'Key OpenAI h·ª£p l·ªá v√† c√≥ quy·ªÅn truy c·∫≠p models.', advice: 'B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng key n√†y. Theo d√µi h·∫°n m·ª©c v√† thanh to√°n tr√™n trang qu·∫£n tr·ªã c·ªßa OpenAI.' };
            }
            const errorMessage = await getErrorMessage(response);
            switch (response.status) {
                case 401: return { status: 'invalid', title: 'Key kh√¥ng h·ª£p l·ªá/h·∫øt h·∫°n', message: errorMessage, advice: 'Ki·ªÉm tra l·∫°i key, ho·∫∑c t·∫°o key m·ªõi. C√≥ th·ªÉ key c·ªßa b·∫°n ƒë√£ b·ªã thu h·ªìi ho·∫∑c h·∫øt h·∫°n t√≠n d·ª•ng.' };
                case 429: return { status: 'limited', title: 'V∆∞·ª£t gi·ªõi h·∫°n truy v·∫•n', message: errorMessage, advice: 'B·∫°n ƒë√£ ƒë·∫°t ƒë·∫øn gi·ªõi h·∫°n y√™u c·∫ßu ho·∫∑c h·∫°n m·ª©c c·ªßa t√†i kho·∫£n. Vui l√≤ng ki·ªÉm tra trang qu·∫£n tr·ªã OpenAI.' };
                default: return { status: 'invalid', title: `L·ªói ${response.status}`, message: errorMessage, advice: 'ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng ki·ªÉm tra trang tr·∫°ng th√°i c·ªßa OpenAI.' };
            }
        }

        // --- Logic k√©o th·∫£ (Drag and Drop) ---
        keyGroupsContainer.addEventListener('dragstart', (e) => {
            const row = e.target.closest('.key-row');
            if (!row) return;
            draggedRow = row;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', row.dataset.id);
            setTimeout(() => {
                row.classList.add('dragging');
            }, 0); // Add class after a brief delay to avoid flickering
        });

        keyGroupsContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            const targetRow = e.target.closest('.key-row');
            if (targetRow && draggedRow && targetRow !== draggedRow && targetRow.dataset.type === draggedRow.dataset.type) {
                const rect = targetRow.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                
                // Remove existing drag-over classes
                targetRow.classList.remove('drag-over-top', 'drag-over-bottom');

                if (offsetY < rect.height / 2) {
                    targetRow.classList.add('drag-over-top');
                } else {
                    targetRow.classList.add('drag-over-bottom');
                }
            }
        });

        keyGroupsContainer.addEventListener('dragleave', (e) => {
            const targetRow = e.target.closest('.key-row');
            if (targetRow) {
                targetRow.classList.remove('drag-over-top', 'drag-over-bottom');
            }
        });

        keyGroupsContainer.addEventListener('drop', async (e) => {
            e.preventDefault();
            const targetRow = e.target.closest('.key-row');

            if (draggedRow && targetRow && targetRow !== draggedRow && targetRow.dataset.type === draggedRow.dataset.type) {
                const draggedId = draggedRow.dataset.id;
                const targetId = targetRow.dataset.id;
                const tbody = targetRow.closest('tbody');
                const rowsInGroup = Array.from(tbody.querySelectorAll('.key-row'));

                const draggedIndex = rowsInGroup.indexOf(draggedRow);
                const targetIndex = rowsInGroup.indexOf(targetRow);

                // Determine new position based on drop location
                const rect = targetRow.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newPosition = targetIndex;

                if (offsetY > rect.height / 2) { // Dropped below the middle of the target row
                    if (draggedIndex < targetIndex) {
                        newPosition = targetIndex;
                    } else {
                        newPosition = targetIndex + 1;
                    }
                } else { // Dropped above the middle of the target row
                    if (draggedIndex < targetIndex) {
                        newPosition = targetIndex -1;
                    } else {
                        newPosition = targetIndex;
                    }
                }
                
                // Ensure newPosition is within bounds
                newPosition = Math.max(0, Math.min(rowsInGroup.length - 1, newPosition));

                // Remove the dragged row from its current position in the DOM
                tbody.removeChild(draggedRow);

                // Insert the dragged row at the new position
                if (newPosition === rowsInGroup.length -1 && offsetY > rect.height / 2) {
                    tbody.appendChild(draggedRow);
                } else if (rowsInGroup[newPosition]) {
                    tbody.insertBefore(draggedRow, rowsInGroup[newPosition]);
                } else {
                    tbody.appendChild(draggedRow); // Fallback if position calculation is off
                }

                // Update 'order' in allLoadedKeys and persist to backend
                const draggedKeyInArray = allLoadedKeys.find(k => k.id === draggedId);
                const targetKeyInArray = allLoadedKeys.find(k => k.id === targetId);

                if (draggedKeyInArray && targetKeyInArray) {
                    // Update order values based on new visual order
                    const updatedOrders = [];
                    const tempKeys = [...allLoadedKeys]; // Create a mutable copy
                    
                    // Remove dragged key from its original position in tempKeys
                    const oldDraggedIndex = tempKeys.findIndex(k => k.id === draggedId);
                    const [removedKey] = tempKeys.splice(oldDraggedIndex, 1);

                    // Insert removedKey at its new logical position within its type group
                    const keysOfType = tempKeys.filter(k => k.type === draggedKeyInArray.type);
                    const otherKeys = tempKeys.filter(k => k.type !== draggedKeyInArray.type);

                    // Find the new index within its type group
                    const targetRowInDOM = tbody.querySelector(`[data-id="${targetId}"]`);
                    const newIndexInDOM = Array.from(tbody.children).indexOf(draggedRow); // Get the actual new index in DOM

                    // Reconstruct the `allLoadedKeys` based on the new DOM order
                    const newOrderedKeysInGroup = Array.from(tbody.children).map(row => allLoadedKeys.find(k => k.id === row.dataset.id));
                    
                    // Assign new order values based on the new sequence
                    newOrderedKeysInGroup.forEach((key, index) => {
                        if (key) {
                            key.order = index; // Simple sequential order
                        }
                    });

                    // Persist changes for all keys in the affected group
                    for (const key of newOrderedKeysInGroup) {
                        if (key) {
                            await apiFetch(`/api/keys/${key.id}`, { method: 'PUT', body: JSON.stringify({ order: key.order, notes: key.notes, favorite: key.favorite }) });
                        }
                    }
                    showToast('ƒê√£ s·∫Øp x·∫øp l·∫°i API key.');
                    loadKeys(); // Re-render to ensure consistency
                }
            }
            // Clean up drag-over classes from all rows
            document.querySelectorAll('.key-row').forEach(row => {
                row.classList.remove('drag-over-top', 'drag-over-bottom');
            });
        });

        keyGroupsContainer.addEventListener('dragend', (e) => {
            draggedRow.classList.remove('dragging');
            draggedRow = null;
            // Clean up any lingering drag-over classes
            document.querySelectorAll('.key-row').forEach(row => {
                row.classList.remove('drag-over-top', 'drag-over-bottom');
            });
        });

        // --- Logic n√∫t Ki·ªÉm tra t·∫•t c·∫£ (t·ªïng th·ªÉ) ---
        checkAllBtn.addEventListener('click', async () => {
            const checkAllBtnText = document.getElementById('check-all-btn-text');
            const checkAllLoader = document.getElementById('check-all-loader');
            
            checkAllBtn.disabled = true;
            checkAllBtnText.classList.add('hidden');
            checkAllLoader.classList.remove('hidden');

            // Ch·ªçn t·∫•t c·∫£ c√°c h√†ng key, b·∫•t k·ªÉ nh√≥m
            const allKeyRows = document.querySelectorAll('.key-row');
            for (const row of allKeyRows) {
                await checkKeyStatus(row, row.dataset.value, row.dataset.type);
                await new Promise(resolve => setTimeout(resolve, 300)); // Th√™m ƒë·ªô tr·ªÖ nh·ªè ƒë·ªÉ tr√°nh rate limit
            }
            
            checkAllBtn.disabled = false;
            checkAllBtnText.classList.remove('hidden');
            checkAllLoader.classList.add('hidden');
            showToast("ƒê√£ ho√†n t·∫•t ki·ªÉm tra t·∫•t c·∫£ c√°c key.");
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }
    </script>
</body>
</html>
